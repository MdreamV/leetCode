#### 单链表

##### 添加：

​	头节点：不存放具体数据，只表示链表头

​	中间节点：包括数据和next，添加到链表的最后

​	尾节点：next为null

##### 展示：

​	通过一个辅助变量，帮助遍历链表

##### 按照编号的顺序添加：

​	假设新的要在A和B之间

​	找到新添加的节点的位置，通过辅助指针 temp = A

​	新的节点的node.next = temp.next （即B）

​	temp.next = node

##### 修改：

​	通过遍历，先找到该节点

​	找到之后：

```java
temp.name = newNode.name; 
```

##### 删除一个节点：

​	找到待删除节点的**前一个节点**。

```java
temp.next = temp.next.next;
```

#### 面试题：

##### 1. 求单链表中有效节点的个数

见代码

##### 2.查找单链表中倒数第k个节点（新浪）

思路：先拿到总长度，再用总长度-k即可

##### 3.单链表的反转（腾讯）

思路：

 	1.	定义一个节点 reverseHead = new HeadNode();
 	2.	从头到尾遍历原来的链表，每遍历一个节点就把他取出，放在新的链表的**最前端**。
      	1.	如果是第一个节点，这个节点要成为新链表的尾巴，所以把他放在新头后面，next = null。
      	2.	后续的节点直接插入新头和这个尾巴直接即可。
 	3.	原链表的head.next = reverseHead .next（换头）。

##### 4.从尾到头打印单链表，要求方式a、反向遍历；b、栈（百度）

思路：

1. 题目只是反向打印链表，不能反转之后再打印。
2. 递归
3. 利用栈这个数据结构，节点压栈，弹栈打印

##### 5.合并两个有序的单链表，合并之后的链表仍然有序。	